{
    "sourceFile": "src/app/api/recommend-pokemon/route.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1743561499817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1743561514100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,271 @@\n+import { getAllPokemon, getPokemonDetails } from '@/lib/pokemon-api';\n+\n+// app/api/recommend-pokemon/route.ts\n+import { NextResponse } from 'next/server';\n+\n+type PokemonType = string;\n+\n+interface PokemonInput {\n+  id: number;\n+  name: string;\n+  types: PokemonType[];\n+  stats: { name: string; value: number }[];\n+  abilities: string[];\n+}\n+\n+interface TypeEffectiveness {\n+  [key: string]: number;\n+}\n+\n+interface PokemonStat {\n+  stat: {\n+    name: string;\n+  };\n+  base_stat: number;\n+}\n+\n+interface PokemonDetail {\n+  id: number;\n+  name: string;\n+  types: { type: { name: string } }[];\n+  stats: PokemonStat[];\n+}\n+\n+interface TeamAnalysis {\n+  typeCount: Record<string, number>;\n+  avgStats: Record<string, number>;\n+  weaknesses: Record<string, number>;\n+  resistances: Record<string, number>;\n+}\n+\n+// 타입 효과 관계 (매우 간소화된 버전)\n+const typeEffectiveness: Record<PokemonType, TypeEffectiveness> = {\n+  normal: { fighting: 2, ghost: 0 },\n+  fire: { fire: 0.5, water: 2, grass: 0.5, ice: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },\n+  water: { fire: 0.5, water: 0.5, grass: 2, electric: 2, ice: 0.5, steel: 0.5 },\n+  electric: { electric: 0.5, ground: 2, flying: 0.5, steel: 0.5 },\n+  grass: { fire: 2, water: 0.5, grass: 0.5, poison: 2, ground: 0.5, flying: 2, bug: 2, ice: 2 },\n+  ice: { fire: 2, ice: 0.5, fighting: 2, rock: 2, steel: 2 },\n+  fighting: { flying: 2, psychic: 2, bug: 0.5, rock: 0.5, dark: 0.5 },\n+  poison: { grass: 0.5, poison: 0.5, ground: 2, psychic: 2, bug: 0.5 },\n+  ground: { water: 2, grass: 2, electric: 0, poison: 0.5, rock: 0.5, ice: 2 },\n+  flying: { electric: 2, grass: 0.5, ice: 2, fighting: 0.5, ground: 0, bug: 0.5, rock: 2 },\n+  psychic: { fighting: 0.5, psychic: 0.5, bug: 2, ghost: 2, dark: 2 },\n+  bug: { fire: 2, grass: 0.5, fighting: 0.5, poison: 0.5, flying: 2, rock: 2 },\n+  rock: { normal: 0.5, fire: 0.5, water: 2, grass: 2, fighting: 2, poison: 0.5, ground: 2, steel: 2 },\n+  ghost: { normal: 0, fighting: 0, poison: 0.5, bug: 0.5, ghost: 2, dark: 2 },\n+  dragon: { dragon: 2, ice: 2, fairy: 2 },\n+  dark: { fighting: 2, psychic: 0, bug: 2, ghost: 0.5, dark: 0.5, fairy: 2 },\n+  steel: { fire: 2, water: 0.5, electric: 0.5, ice: 0.5, rock: 0.5, steel: 0.5, fairy: 0.5 },\n+  fairy: { fighting: 0.5, poison: 2, bug: 0.5, dragon: 0, dark: 0.5, steel: 2 }\n+};\n+\n+export async function POST(request: Request) {\n+  try {\n+    const { selectedPokemon } = await request.json() as { selectedPokemon: PokemonInput[] };\n+\n+    if (!selectedPokemon || !Array.isArray(selectedPokemon) || selectedPokemon.length < 2) {\n+      return NextResponse.json({ error: '최소 2마리의 포켓몬이 필요합니다' }, { status: 400 });\n+    }\n+\n+    // 1. 팀 분석: 타입 커버리지, 약점, 스탯 등 분석\n+    const teamAnalysis = analyzeTeam(selectedPokemon);\n+\n+    // 2. 후보 포켓몬 목록 가져오기 (간단히 151마리 제한)\n+    const allPokemon = await getAllPokemon(151);\n+    \n+    // 3. 이미 선택된 포켓몬 제외\n+    const selectedIds = selectedPokemon.map(p => p.id);\n+    const candidatePokemonURLs = allPokemon.filter(p => {\n+      const id = extractIdFromUrl(p.url);\n+      return !selectedIds.includes(parseInt(id));\n+    });\n+\n+    // 4. 후보 포켓몬 상세 정보 가져오기 (속도를 위해 최대 20개로 제한)\n+    const candidateDetails = await Promise.all(\n+      candidatePokemonURLs.slice(0, 20).map(async p => {\n+        const id = extractIdFromUrl(p.url);\n+        return await getPokemonDetails(id);\n+      })\n+    );\n+\n+    // 5. 후보 포켓몬 점수 계산\n+    const scoredCandidates = candidateDetails.map(pokemon => {\n+      const score = calculateCompatibilityScore(pokemon, teamAnalysis);\n+      const reasons = generateRecommendationReasons(pokemon, teamAnalysis);\n+      \n+      return {\n+        id: pokemon.id,\n+        name: pokemon.name,\n+        types: pokemon.types.map(t => t.type.name),\n+        score,\n+        reasons\n+      };\n+    });\n+\n+    // 6. 점수 기준으로 정렬하고 상위 결과 반환\n+    const recommendations = scoredCandidates\n+      .sort((a, b) => b.score - a.score)\n+      .slice(0, 6);\n+\n+    return NextResponse.json({ recommendations });\n+  } catch (error) {\n+    console.error('Error in recommendation API:', error);\n+    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n+  }\n+}\n+\n+// 팀 분석 함수\n+function analyzeTeam(pokemon: PokemonInput[]) {\n+  // 현재 팀의 타입 목록\n+  const teamTypes = pokemon.flatMap(p => p.types);\n+  \n+  // 타입별 포켓몬 수\n+  const typeCount: Record<string, number> = {};\n+  teamTypes.forEach(type => {\n+    typeCount[type] = (typeCount[type] || 0) + 1;\n+  });\n+  \n+  // 현재 팀의 평균 스탯\n+  const avgStats: Record<string, number> = {};\n+  const statFields = ['hp', 'attack', 'defense', 'special-attack', 'special-defense', 'speed'];\n+  \n+  statFields.forEach(stat => {\n+    const total = pokemon.reduce((sum, p) => {\n+      const statObj = p.stats.find(s => s.name === stat);\n+      return sum + (statObj ? statObj.value : 0);\n+    }, 0);\n+    \n+    avgStats[stat] = total / pokemon.length;\n+  });\n+  \n+  // 타입별 약점 계산\n+  const weaknesses: Record<string, number> = {};\n+  const resistances: Record<string, number> = {};\n+  \n+  Object.keys(typeEffectiveness).forEach(attackType => {\n+    // 모든 타입에 대한 데미지 배율 계산\n+    let totalDamageMultiplier = 1;\n+    \n+    teamTypes.forEach(defenseType => {\n+      if (typeEffectiveness[attackType][defenseType]) {\n+        totalDamageMultiplier *= typeEffectiveness[attackType][defenseType];\n+      }\n+    });\n+    \n+    // 평균 배율로 약점/저항성 저장\n+    const avgMultiplier = totalDamageMultiplier / teamTypes.length;\n+    \n+    if (avgMultiplier > 1) {\n+      weaknesses[attackType] = avgMultiplier;\n+    } else if (avgMultiplier < 1) {\n+      resistances[attackType] = avgMultiplier;\n+    }\n+  });\n+  \n+  return {\n+    typeCount,\n+    avgStats,\n+    weaknesses,\n+    resistances\n+  };\n+}\n+\n+// 호환성 점수 계산 함수\n+function calculateCompatibilityScore(pokemon: PokemonDetail, teamAnalysis: TeamAnalysis) {\n+  let score = 0;\n+  const pokemonTypes = pokemon.types.map(t => t.type.name);\n+  \n+  // 1. 타입 다양성 점수 (팀에 없는 타입)\n+  pokemonTypes.forEach((type: string) => {\n+    if (!teamAnalysis.typeCount[type]) {\n+      score += 10; // 새로운 타입은 높은 점수\n+    } else {\n+      score -= teamAnalysis.typeCount[type] * 5; // 중복 타입은 감점\n+    }\n+  });\n+  \n+  // 2. 약점 보완 점수\n+  Object.entries(teamAnalysis.weaknesses).forEach(([type, multiplier]) => {\n+    if (pokemonTypes.some((t: PokemonType) => {\n+      return typeEffectiveness[type as PokemonType][t] && typeEffectiveness[type as PokemonType][t] < 1;\n+    })) {\n+      score += 15 * (Number(multiplier) - 1); // 약점을 보완할수록 높은 점수\n+    }\n+  });\n+  \n+  // 3. 스탯 밸런스 점수\n+  const lowStats = Object.entries(teamAnalysis.avgStats)\n+    .filter(([_, value]) => (value as number) < 70) // 낮은 스탯 기준\n+    .map(([stat]) => stat);\n+  \n+  pokemon.stats.forEach((stat: PokemonStat) => {\n+    if (lowStats.includes(stat.stat.name) && stat.base_stat > 80) {\n+      score += 5; // 팀의 약점을 보완하는 높은 스탯\n+    }\n+  });\n+  \n+  // 4. 특성 가산점 (단순화)\n+  score += 5;\n+  \n+  return score;\n+}\n+\n+// 추천 이유 생성 함수\n+function generateRecommendationReasons(pokemon: PokemonDetail, teamAnalysis: TeamAnalysis) {\n+  const reasons = [];\n+  const pokemonTypes = pokemon.types.map(t => t.type.name);\n+  \n+  // 타입 다양성 이유\n+const newTypes: PokemonType[] = pokemonTypes.filter((type: PokemonType) => !teamAnalysis.typeCount[type]);\n+  if (newTypes.length > 0) {\n+    reasons.push(`팀에 없는 ${newTypes.join(', ')} 타입을 추가합니다`);\n+  }\n+  \n+  // 약점 보완 이유\n+  const coveredWeaknesses = Object.entries(teamAnalysis.weaknesses)\n+    .filter(([type]) => {\n+    return pokemonTypes.some((t: PokemonType) => \n+      typeEffectiveness[type as PokemonType][t] && typeEffectiveness[type as PokemonType][t] < 1\n+    );\n+    })\n+    .map(([type]) => type);\n+  \n+  if (coveredWeaknesses.length > 0) {\n+    reasons.push(`팀의 ${coveredWeaknesses.join(', ')} 타입 약점을 보완합니다`);\n+  }\n+  \n+  // 스탯 보완 이유\n+  const lowStats = Object.entries(teamAnalysis.avgStats)\n+    .filter(([_, value]) => (value as number) < 70)\n+    .map(([stat]) => stat);\n+  \n+  const highStats = pokemon.stats\n+    .filter((stat: PokemonStat) => lowStats.includes(stat.stat.name) && stat.base_stat > 80)\n+    .map((stat: PokemonStat) => {\n+      const statName = stat.stat.name === 'hp' ? 'HP' :\n+        stat.stat.name === 'special-attack' ? '특수공격' :\n+        stat.stat.name === 'special-defense' ? '특수방어' :\n+        stat.stat.name === 'attack' ? '공격' :\n+        stat.stat.name === 'defense' ? '방어' : '스피드';\n+      \n+      return `${statName}(${stat.base_stat})`;\n+    });\n+  \n+  if (highStats.length > 0) {\n+    reasons.push(`팀의 낮은 스탯을 보완: ${highStats.join(', ')}`);\n+  }\n+  \n+  // 기본 이유 (항상 최소 하나의 이유 제공)\n+  if (reasons.length === 0) {\n+    reasons.push('전반적으로 팀 밸런스를 개선합니다');\n+  }\n+  \n+  return reasons;\n+}\n+\n+// URL에서 포켓몬 ID 추출\n+function extractIdFromUrl(url: string): string {\n+  const parts = url.split('/');\n+  return parts[parts.length - 2];\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1743561541549,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,9 +195,9 @@\n   });\n   \n   // 3. 스탯 밸런스 점수\n   const lowStats = Object.entries(teamAnalysis.avgStats)\n-    .filter(([_, value]) => (value as number) < 70) // 낮은 스탯 기준\n+    .filter(([, value]) => (value as number) < 70) // 낮은 스탯 기준\n     .map(([stat]) => stat);\n   \n   pokemon.stats.forEach((stat: PokemonStat) => {\n     if (lowStats.includes(stat.stat.name) && stat.base_stat > 80) {\n@@ -236,9 +236,9 @@\n   }\n   \n   // 스탯 보완 이유\n   const lowStats = Object.entries(teamAnalysis.avgStats)\n-    .filter(([_, value]) => (value as number) < 70)\n+    .filter(([, value]) => (value as number) < 70)\n     .map(([stat]) => stat);\n   \n   const highStats = pokemon.stats\n     .filter((stat: PokemonStat) => lowStats.includes(stat.stat.name) && stat.base_stat > 80)\n@@ -267,276 +267,5 @@\n // URL에서 포켓몬 ID 추출\n function extractIdFromUrl(url: string): string {\n   const parts = url.split('/');\n   return parts[parts.length - 2];\n-}\n-import { getAllPokemon, getPokemonDetails } from '@/lib/pokemon-api';\n-\n-// app/api/recommend-pokemon/route.ts\n-import { NextResponse } from 'next/server';\n-\n-type PokemonType = string;\n-\n-interface PokemonInput {\n-  id: number;\n-  name: string;\n-  types: PokemonType[];\n-  stats: { name: string; value: number }[];\n-  abilities: string[];\n-}\n-\n-interface TypeEffectiveness {\n-  [key: string]: number;\n-}\n-\n-interface PokemonStat {\n-  stat: {\n-    name: string;\n-  };\n-  base_stat: number;\n-}\n-\n-interface PokemonDetail {\n-  id: number;\n-  name: string;\n-  types: { type: { name: string } }[];\n-  stats: PokemonStat[];\n-}\n-\n-interface TeamAnalysis {\n-  typeCount: Record<string, number>;\n-  avgStats: Record<string, number>;\n-  weaknesses: Record<string, number>;\n-  resistances: Record<string, number>;\n-}\n-\n-// 타입 효과 관계 (매우 간소화된 버전)\n-const typeEffectiveness: Record<PokemonType, TypeEffectiveness> = {\n-  normal: { fighting: 2, ghost: 0 },\n-  fire: { fire: 0.5, water: 2, grass: 0.5, ice: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },\n-  water: { fire: 0.5, water: 0.5, grass: 2, electric: 2, ice: 0.5, steel: 0.5 },\n-  electric: { electric: 0.5, ground: 2, flying: 0.5, steel: 0.5 },\n-  grass: { fire: 2, water: 0.5, grass: 0.5, poison: 2, ground: 0.5, flying: 2, bug: 2, ice: 2 },\n-  ice: { fire: 2, ice: 0.5, fighting: 2, rock: 2, steel: 2 },\n-  fighting: { flying: 2, psychic: 2, bug: 0.5, rock: 0.5, dark: 0.5 },\n-  poison: { grass: 0.5, poison: 0.5, ground: 2, psychic: 2, bug: 0.5 },\n-  ground: { water: 2, grass: 2, electric: 0, poison: 0.5, rock: 0.5, ice: 2 },\n-  flying: { electric: 2, grass: 0.5, ice: 2, fighting: 0.5, ground: 0, bug: 0.5, rock: 2 },\n-  psychic: { fighting: 0.5, psychic: 0.5, bug: 2, ghost: 2, dark: 2 },\n-  bug: { fire: 2, grass: 0.5, fighting: 0.5, poison: 0.5, flying: 2, rock: 2 },\n-  rock: { normal: 0.5, fire: 0.5, water: 2, grass: 2, fighting: 2, poison: 0.5, ground: 2, steel: 2 },\n-  ghost: { normal: 0, fighting: 0, poison: 0.5, bug: 0.5, ghost: 2, dark: 2 },\n-  dragon: { dragon: 2, ice: 2, fairy: 2 },\n-  dark: { fighting: 2, psychic: 0, bug: 2, ghost: 0.5, dark: 0.5, fairy: 2 },\n-  steel: { fire: 2, water: 0.5, electric: 0.5, ice: 0.5, rock: 0.5, steel: 0.5, fairy: 0.5 },\n-  fairy: { fighting: 0.5, poison: 2, bug: 0.5, dragon: 0, dark: 0.5, steel: 2 }\n-};\n-\n-export async function POST(request: Request) {\n-  try {\n-    const { selectedPokemon } = await request.json() as { selectedPokemon: PokemonInput[] };\n-\n-    if (!selectedPokemon || !Array.isArray(selectedPokemon) || selectedPokemon.length < 2) {\n-      return NextResponse.json({ error: '최소 2마리의 포켓몬이 필요합니다' }, { status: 400 });\n-    }\n-\n-    // 1. 팀 분석: 타입 커버리지, 약점, 스탯 등 분석\n-    const teamAnalysis = analyzeTeam(selectedPokemon);\n-\n-    // 2. 후보 포켓몬 목록 가져오기 (간단히 151마리 제한)\n-    const allPokemon = await getAllPokemon(151);\n-    \n-    // 3. 이미 선택된 포켓몬 제외\n-    const selectedIds = selectedPokemon.map(p => p.id);\n-    const candidatePokemonURLs = allPokemon.filter(p => {\n-      const id = extractIdFromUrl(p.url);\n-      return !selectedIds.includes(parseInt(id));\n-    });\n-\n-    // 4. 후보 포켓몬 상세 정보 가져오기 (속도를 위해 최대 20개로 제한)\n-    const candidateDetails = await Promise.all(\n-      candidatePokemonURLs.slice(0, 20).map(async p => {\n-        const id = extractIdFromUrl(p.url);\n-        return await getPokemonDetails(id);\n-      })\n-    );\n-\n-    // 5. 후보 포켓몬 점수 계산\n-    const scoredCandidates = candidateDetails.map(pokemon => {\n-      const score = calculateCompatibilityScore(pokemon, teamAnalysis);\n-      const reasons = generateRecommendationReasons(pokemon, teamAnalysis);\n-      \n-      return {\n-        id: pokemon.id,\n-        name: pokemon.name,\n-        types: pokemon.types.map(t => t.type.name),\n-        score,\n-        reasons\n-      };\n-    });\n-\n-    // 6. 점수 기준으로 정렬하고 상위 결과 반환\n-    const recommendations = scoredCandidates\n-      .sort((a, b) => b.score - a.score)\n-      .slice(0, 6);\n-\n-    return NextResponse.json({ recommendations });\n-  } catch (error) {\n-    console.error('Error in recommendation API:', error);\n-    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n-  }\n-}\n-\n-// 팀 분석 함수\n-function analyzeTeam(pokemon: PokemonInput[]) {\n-  // 현재 팀의 타입 목록\n-  const teamTypes = pokemon.flatMap(p => p.types);\n-  \n-  // 타입별 포켓몬 수\n-  const typeCount: Record<string, number> = {};\n-  teamTypes.forEach(type => {\n-    typeCount[type] = (typeCount[type] || 0) + 1;\n-  });\n-  \n-  // 현재 팀의 평균 스탯\n-  const avgStats: Record<string, number> = {};\n-  const statFields = ['hp', 'attack', 'defense', 'special-attack', 'special-defense', 'speed'];\n-  \n-  statFields.forEach(stat => {\n-    const total = pokemon.reduce((sum, p) => {\n-      const statObj = p.stats.find(s => s.name === stat);\n-      return sum + (statObj ? statObj.value : 0);\n-    }, 0);\n-    \n-    avgStats[stat] = total / pokemon.length;\n-  });\n-  \n-  // 타입별 약점 계산\n-  const weaknesses: Record<string, number> = {};\n-  const resistances: Record<string, number> = {};\n-  \n-  Object.keys(typeEffectiveness).forEach(attackType => {\n-    // 모든 타입에 대한 데미지 배율 계산\n-    let totalDamageMultiplier = 1;\n-    \n-    teamTypes.forEach(defenseType => {\n-      if (typeEffectiveness[attackType][defenseType]) {\n-        totalDamageMultiplier *= typeEffectiveness[attackType][defenseType];\n-      }\n-    });\n-    \n-    // 평균 배율로 약점/저항성 저장\n-    const avgMultiplier = totalDamageMultiplier / teamTypes.length;\n-    \n-    if (avgMultiplier > 1) {\n-      weaknesses[attackType] = avgMultiplier;\n-    } else if (avgMultiplier < 1) {\n-      resistances[attackType] = avgMultiplier;\n-    }\n-  });\n-  \n-  return {\n-    typeCount,\n-    avgStats,\n-    weaknesses,\n-    resistances\n-  };\n-}\n-\n-// 호환성 점수 계산 함수\n-function calculateCompatibilityScore(pokemon: PokemonDetail, teamAnalysis: TeamAnalysis) {\n-  let score = 0;\n-  const pokemonTypes = pokemon.types.map(t => t.type.name);\n-  \n-  // 1. 타입 다양성 점수 (팀에 없는 타입)\n-  pokemonTypes.forEach((type: string) => {\n-    if (!teamAnalysis.typeCount[type]) {\n-      score += 10; // 새로운 타입은 높은 점수\n-    } else {\n-      score -= teamAnalysis.typeCount[type] * 5; // 중복 타입은 감점\n-    }\n-  });\n-  \n-  // 2. 약점 보완 점수\n-  Object.entries(teamAnalysis.weaknesses).forEach(([type, multiplier]) => {\n-    if (pokemonTypes.some((t: PokemonType) => {\n-      return typeEffectiveness[type as PokemonType][t] && typeEffectiveness[type as PokemonType][t] < 1;\n-    })) {\n-      score += 15 * (Number(multiplier) - 1); // 약점을 보완할수록 높은 점수\n-    }\n-  });\n-  \n-  // 3. 스탯 밸런스 점수\n-  const lowStats = Object.entries(teamAnalysis.avgStats)\n-    .filter(([_, value]) => (value as number) < 70) // 낮은 스탯 기준\n-    .map(([stat]) => stat);\n-  \n-  pokemon.stats.forEach((stat: PokemonStat) => {\n-    if (lowStats.includes(stat.stat.name) && stat.base_stat > 80) {\n-      score += 5; // 팀의 약점을 보완하는 높은 스탯\n-    }\n-  });\n-  \n-  // 4. 특성 가산점 (단순화)\n-  score += 5;\n-  \n-  return score;\n-}\n-\n-// 추천 이유 생성 함수\n-function generateRecommendationReasons(pokemon: PokemonDetail, teamAnalysis: TeamAnalysis) {\n-  const reasons = [];\n-  const pokemonTypes = pokemon.types.map(t => t.type.name);\n-  \n-  // 타입 다양성 이유\n-const newTypes: PokemonType[] = pokemonTypes.filter((type: PokemonType) => !teamAnalysis.typeCount[type]);\n-  if (newTypes.length > 0) {\n-    reasons.push(`팀에 없는 ${newTypes.join(', ')} 타입을 추가합니다`);\n-  }\n-  \n-  // 약점 보완 이유\n-  const coveredWeaknesses = Object.entries(teamAnalysis.weaknesses)\n-    .filter(([type]) => {\n-    return pokemonTypes.some((t: PokemonType) => \n-      typeEffectiveness[type as PokemonType][t] && typeEffectiveness[type as PokemonType][t] < 1\n-    );\n-    })\n-    .map(([type]) => type);\n-  \n-  if (coveredWeaknesses.length > 0) {\n-    reasons.push(`팀의 ${coveredWeaknesses.join(', ')} 타입 약점을 보완합니다`);\n-  }\n-  \n-  // 스탯 보완 이유\n-  const lowStats = Object.entries(teamAnalysis.avgStats)\n-    .filter(([_, value]) => (value as number) < 70)\n-    .map(([stat]) => stat);\n-  \n-  const highStats = pokemon.stats\n-    .filter((stat: PokemonStat) => lowStats.includes(stat.stat.name) && stat.base_stat > 80)\n-    .map((stat: PokemonStat) => {\n-      const statName = stat.stat.name === 'hp' ? 'HP' :\n-        stat.stat.name === 'special-attack' ? '특수공격' :\n-        stat.stat.name === 'special-defense' ? '특수방어' :\n-        stat.stat.name === 'attack' ? '공격' :\n-        stat.stat.name === 'defense' ? '방어' : '스피드';\n-      \n-      return `${statName}(${stat.base_stat})`;\n-    });\n-  \n-  if (highStats.length > 0) {\n-    reasons.push(`팀의 낮은 스탯을 보완: ${highStats.join(', ')}`);\n-  }\n-  \n-  // 기본 이유 (항상 최소 하나의 이유 제공)\n-  if (reasons.length === 0) {\n-    reasons.push('전반적으로 팀 밸런스를 개선합니다');\n-  }\n-  \n-  return reasons;\n-}\n-\n-// URL에서 포켓몬 ID 추출\n-function extractIdFromUrl(url: string): string {\n-  const parts = url.split('/');\n-  return parts[parts.length - 2];\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1743562513262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n import { getAllPokemon, getPokemonDetails } from '@/lib/pokemon-api';\n \n-// app/api/recommend-pokemon/route.ts\n import { NextResponse } from 'next/server';\n \n type PokemonType = string;\n \n"
                }
            ],
            "date": 1743561499817,
            "name": "Commit-0",
            "content": "import { getAllPokemon, getPokemonDetails } from '@/lib/pokemon-api';\n\n// app/api/recommend-pokemon/route.ts\nimport { NextResponse } from 'next/server';\n\ntype PokemonType = string;\n\ninterface PokemonInput {\n  id: number;\n  name: string;\n  types: PokemonType[];\n  stats: { name: string; value: number }[];\n  abilities: string[];\n}\n\ninterface TypeEffectiveness {\n  [key: string]: number;\n}\n\ninterface PokemonStat {\n  stat: {\n    name: string;\n  };\n  base_stat: number;\n}\n\ninterface PokemonDetail {\n  id: number;\n  name: string;\n  types: { type: { name: string } }[];\n  stats: PokemonStat[];\n}\n\ninterface TeamAnalysis {\n  typeCount: Record<string, number>;\n  avgStats: Record<string, number>;\n  weaknesses: Record<string, number>;\n  resistances: Record<string, number>;\n}\n\n// 타입 효과 관계 (매우 간소화된 버전)\nconst typeEffectiveness: Record<PokemonType, TypeEffectiveness> = {\n  normal: { fighting: 2, ghost: 0 },\n  fire: { fire: 0.5, water: 2, grass: 0.5, ice: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },\n  water: { fire: 0.5, water: 0.5, grass: 2, electric: 2, ice: 0.5, steel: 0.5 },\n  electric: { electric: 0.5, ground: 2, flying: 0.5, steel: 0.5 },\n  grass: { fire: 2, water: 0.5, grass: 0.5, poison: 2, ground: 0.5, flying: 2, bug: 2, ice: 2 },\n  ice: { fire: 2, ice: 0.5, fighting: 2, rock: 2, steel: 2 },\n  fighting: { flying: 2, psychic: 2, bug: 0.5, rock: 0.5, dark: 0.5 },\n  poison: { grass: 0.5, poison: 0.5, ground: 2, psychic: 2, bug: 0.5 },\n  ground: { water: 2, grass: 2, electric: 0, poison: 0.5, rock: 0.5, ice: 2 },\n  flying: { electric: 2, grass: 0.5, ice: 2, fighting: 0.5, ground: 0, bug: 0.5, rock: 2 },\n  psychic: { fighting: 0.5, psychic: 0.5, bug: 2, ghost: 2, dark: 2 },\n  bug: { fire: 2, grass: 0.5, fighting: 0.5, poison: 0.5, flying: 2, rock: 2 },\n  rock: { normal: 0.5, fire: 0.5, water: 2, grass: 2, fighting: 2, poison: 0.5, ground: 2, steel: 2 },\n  ghost: { normal: 0, fighting: 0, poison: 0.5, bug: 0.5, ghost: 2, dark: 2 },\n  dragon: { dragon: 2, ice: 2, fairy: 2 },\n  dark: { fighting: 2, psychic: 0, bug: 2, ghost: 0.5, dark: 0.5, fairy: 2 },\n  steel: { fire: 2, water: 0.5, electric: 0.5, ice: 0.5, rock: 0.5, steel: 0.5, fairy: 0.5 },\n  fairy: { fighting: 0.5, poison: 2, bug: 0.5, dragon: 0, dark: 0.5, steel: 2 }\n};\n\nexport async function POST(request: Request) {\n  try {\n    const { selectedPokemon } = await request.json() as { selectedPokemon: PokemonInput[] };\n\n    if (!selectedPokemon || !Array.isArray(selectedPokemon) || selectedPokemon.length < 2) {\n      return NextResponse.json({ error: '최소 2마리의 포켓몬이 필요합니다' }, { status: 400 });\n    }\n\n    // 1. 팀 분석: 타입 커버리지, 약점, 스탯 등 분석\n    const teamAnalysis = analyzeTeam(selectedPokemon);\n\n    // 2. 후보 포켓몬 목록 가져오기 (간단히 151마리 제한)\n    const allPokemon = await getAllPokemon(151);\n    \n    // 3. 이미 선택된 포켓몬 제외\n    const selectedIds = selectedPokemon.map(p => p.id);\n    const candidatePokemonURLs = allPokemon.filter(p => {\n      const id = extractIdFromUrl(p.url);\n      return !selectedIds.includes(parseInt(id));\n    });\n\n    // 4. 후보 포켓몬 상세 정보 가져오기 (속도를 위해 최대 20개로 제한)\n    const candidateDetails = await Promise.all(\n      candidatePokemonURLs.slice(0, 20).map(async p => {\n        const id = extractIdFromUrl(p.url);\n        return await getPokemonDetails(id);\n      })\n    );\n\n    // 5. 후보 포켓몬 점수 계산\n    const scoredCandidates = candidateDetails.map(pokemon => {\n      const score = calculateCompatibilityScore(pokemon, teamAnalysis);\n      const reasons = generateRecommendationReasons(pokemon, teamAnalysis);\n      \n      return {\n        id: pokemon.id,\n        name: pokemon.name,\n        types: pokemon.types.map(t => t.type.name),\n        score,\n        reasons\n      };\n    });\n\n    // 6. 점수 기준으로 정렬하고 상위 결과 반환\n    const recommendations = scoredCandidates\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 6);\n\n    return NextResponse.json({ recommendations });\n  } catch (error) {\n    console.error('Error in recommendation API:', error);\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n  }\n}\n\n// 팀 분석 함수\nfunction analyzeTeam(pokemon: PokemonInput[]) {\n  // 현재 팀의 타입 목록\n  const teamTypes = pokemon.flatMap(p => p.types);\n  \n  // 타입별 포켓몬 수\n  const typeCount: Record<string, number> = {};\n  teamTypes.forEach(type => {\n    typeCount[type] = (typeCount[type] || 0) + 1;\n  });\n  \n  // 현재 팀의 평균 스탯\n  const avgStats: Record<string, number> = {};\n  const statFields = ['hp', 'attack', 'defense', 'special-attack', 'special-defense', 'speed'];\n  \n  statFields.forEach(stat => {\n    const total = pokemon.reduce((sum, p) => {\n      const statObj = p.stats.find(s => s.name === stat);\n      return sum + (statObj ? statObj.value : 0);\n    }, 0);\n    \n    avgStats[stat] = total / pokemon.length;\n  });\n  \n  // 타입별 약점 계산\n  const weaknesses: Record<string, number> = {};\n  const resistances: Record<string, number> = {};\n  \n  Object.keys(typeEffectiveness).forEach(attackType => {\n    // 모든 타입에 대한 데미지 배율 계산\n    let totalDamageMultiplier = 1;\n    \n    teamTypes.forEach(defenseType => {\n      if (typeEffectiveness[attackType][defenseType]) {\n        totalDamageMultiplier *= typeEffectiveness[attackType][defenseType];\n      }\n    });\n    \n    // 평균 배율로 약점/저항성 저장\n    const avgMultiplier = totalDamageMultiplier / teamTypes.length;\n    \n    if (avgMultiplier > 1) {\n      weaknesses[attackType] = avgMultiplier;\n    } else if (avgMultiplier < 1) {\n      resistances[attackType] = avgMultiplier;\n    }\n  });\n  \n  return {\n    typeCount,\n    avgStats,\n    weaknesses,\n    resistances\n  };\n}\n\n// 호환성 점수 계산 함수\nfunction calculateCompatibilityScore(pokemon: PokemonDetail, teamAnalysis: TeamAnalysis) {\n  let score = 0;\n  const pokemonTypes = pokemon.types.map(t => t.type.name);\n  \n  // 1. 타입 다양성 점수 (팀에 없는 타입)\n  pokemonTypes.forEach((type: string) => {\n    if (!teamAnalysis.typeCount[type]) {\n      score += 10; // 새로운 타입은 높은 점수\n    } else {\n      score -= teamAnalysis.typeCount[type] * 5; // 중복 타입은 감점\n    }\n  });\n  \n  // 2. 약점 보완 점수\n  Object.entries(teamAnalysis.weaknesses).forEach(([type, multiplier]) => {\n    if (pokemonTypes.some((t: PokemonType) => {\n      return typeEffectiveness[type as PokemonType][t] && typeEffectiveness[type as PokemonType][t] < 1;\n    })) {\n      score += 15 * (Number(multiplier) - 1); // 약점을 보완할수록 높은 점수\n    }\n  });\n  \n  // 3. 스탯 밸런스 점수\n  const lowStats = Object.entries(teamAnalysis.avgStats)\n    .filter(([_, value]) => (value as number) < 70) // 낮은 스탯 기준\n    .map(([stat]) => stat);\n  \n  pokemon.stats.forEach((stat: PokemonStat) => {\n    if (lowStats.includes(stat.stat.name) && stat.base_stat > 80) {\n      score += 5; // 팀의 약점을 보완하는 높은 스탯\n    }\n  });\n  \n  // 4. 특성 가산점 (단순화)\n  score += 5;\n  \n  return score;\n}\n\n// 추천 이유 생성 함수\nfunction generateRecommendationReasons(pokemon: PokemonDetail, teamAnalysis: TeamAnalysis) {\n  const reasons = [];\n  const pokemonTypes = pokemon.types.map(t => t.type.name);\n  \n  // 타입 다양성 이유\nconst newTypes: PokemonType[] = pokemonTypes.filter((type: PokemonType) => !teamAnalysis.typeCount[type]);\n  if (newTypes.length > 0) {\n    reasons.push(`팀에 없는 ${newTypes.join(', ')} 타입을 추가합니다`);\n  }\n  \n  // 약점 보완 이유\n  const coveredWeaknesses = Object.entries(teamAnalysis.weaknesses)\n    .filter(([type]) => {\n    return pokemonTypes.some((t: PokemonType) => \n      typeEffectiveness[type as PokemonType][t] && typeEffectiveness[type as PokemonType][t] < 1\n    );\n    })\n    .map(([type]) => type);\n  \n  if (coveredWeaknesses.length > 0) {\n    reasons.push(`팀의 ${coveredWeaknesses.join(', ')} 타입 약점을 보완합니다`);\n  }\n  \n  // 스탯 보완 이유\n  const lowStats = Object.entries(teamAnalysis.avgStats)\n    .filter(([_, value]) => (value as number) < 70)\n    .map(([stat]) => stat);\n  \n  const highStats = pokemon.stats\n    .filter((stat: PokemonStat) => lowStats.includes(stat.stat.name) && stat.base_stat > 80)\n    .map((stat: PokemonStat) => {\n      const statName = stat.stat.name === 'hp' ? 'HP' :\n        stat.stat.name === 'special-attack' ? '특수공격' :\n        stat.stat.name === 'special-defense' ? '특수방어' :\n        stat.stat.name === 'attack' ? '공격' :\n        stat.stat.name === 'defense' ? '방어' : '스피드';\n      \n      return `${statName}(${stat.base_stat})`;\n    });\n  \n  if (highStats.length > 0) {\n    reasons.push(`팀의 낮은 스탯을 보완: ${highStats.join(', ')}`);\n  }\n  \n  // 기본 이유 (항상 최소 하나의 이유 제공)\n  if (reasons.length === 0) {\n    reasons.push('전반적으로 팀 밸런스를 개선합니다');\n  }\n  \n  return reasons;\n}\n\n// URL에서 포켓몬 ID 추출\nfunction extractIdFromUrl(url: string): string {\n  const parts = url.split('/');\n  return parts[parts.length - 2];\n}"
        }
    ]
}